import os
import time
import base64
import hashlib
import httpx
from typing import Optional, Dict, Any
from fastapi import Header, HTTPException, Request, Depends
from pydantic import BaseModel
from dotenv import load_dotenv

load_dotenv()

# Load XION blockchain API details from environment variables
XION_API_URL = os.getenv("XION_API_URL")
XION_CONTRACT_ADDRESS = os.getenv("XION_CONTRACT_ADDRESS")
XION_API_KEY = os.getenv("XION_API_KEY", "")

class BlockchainCredentials(BaseModel):
    transaction_hash: str
    public_key: str
    session_token: str

async def verify_blockchain_credentials(
    request: Request,
    x_transaction_hash: str = Header(..., description="Transaction hash from the XION blockchain"),
    x_public_key: str = Header(..., description="User's public key from their wallet"),
    x_session_token: str = Header(..., description="Session token generated by the contract")
) -> BlockchainCredentials:
    """
    Verifies that the request contains valid blockchain credentials from XION.
    
    1. Verifies transaction exists and is confirmed
    2. Checks that the public key matches the transaction sender
    3. Verifies the session token format
    
    Returns the verified blockchain credentials or raises an HTTPException if verification fails.
    """
    # Basic validation
    if not x_transaction_hash.startswith("0x"):
        raise HTTPException(status_code=401, detail="Invalid transaction hash format")
    
    credentials = BlockchainCredentials(
        transaction_hash=x_transaction_hash,
        public_key=x_public_key,
        session_token=x_session_token
    )
    
    # Query XION blockchain to verify transaction
    try:
        # Fetch transaction details from blockchain
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.get(
                f"{XION_API_URL}/cosmos/tx/v1beta1/txs/{x_transaction_hash[2:]}",  # Remove 0x prefix for Cosmos API
                headers={"Authorization": f"Bearer {XION_API_KEY}"} if XION_API_KEY else {}
            )
            
            if response.status_code != 200:
                raise HTTPException(
                    status_code=401, 
                    detail=f"Failed to verify transaction: {response.text}"
                )
            
            tx_data = response.json()
            
            # 1. Verify transaction exists and is successful
            if "code" in tx_data.get("tx_response", {}) and tx_data["tx_response"]["code"] != 0:
                raise HTTPException(
                    status_code=401,
                    detail="Transaction failed on blockchain"
                )
                
            # 2. Verify transaction involves our contract
            events = tx_data.get("tx_response", {}).get("events", [])
            contract_found = False
            cv_request_event = None
            
            for event in events:
                if event.get("type") == "wasm":
                    for attr in event.get("attributes", []):
                        key = base64.b64decode(attr.get("key", "")).decode("utf-8", errors="ignore")
                        value = base64.b64decode(attr.get("value", "")).decode("utf-8", errors="ignore")
                        
                        if key == "_contract_address" and value == XION_CONTRACT_ADDRESS:
                            contract_found = True
                        
                        # Find the cv_request event
                        if key == "action" and value == "record_cv_generation":
                            cv_request_event = event
            
            if not contract_found:
                raise HTTPException(
                    status_code=401,
                    detail="Transaction does not involve the Propellant contract"
                )
                
            # 3. Extract and verify session token from event
            if cv_request_event:
                token_found = False
                user_address = None
                
                for attr in cv_request_event.get("attributes", []):
                    key = base64.b64decode(attr.get("key", "")).decode("utf-8", errors="ignore")
                    value = base64.b64decode(attr.get("value", "")).decode("utf-8", errors="ignore")
                    
                    if key == "token" and value == x_session_token:
                        token_found = True
                    
                    if key == "user":
                        user_address = value
                
                if not token_found:
                    raise HTTPException(
                        status_code=401,
                        detail="Session token does not match blockchain record"
                    )
                
                # 4. Verify user public key matches transaction
                if user_address and user_address != x_public_key:
                    raise HTTPException(
                        status_code=401,
                        detail="Public key does not match transaction sender"
                    )
            else:
                raise HTTPException(
                    status_code=401,
                    detail="CV generation event not found in transaction"
                )
            
            # All verification passed!
            return credentials
            
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error during blockchain verification: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail="Failed to verify blockchain credentials"
        )

# Development/testing mock for local use
async def mock_verify_blockchain_credentials(
    x_transaction_hash: str = Header(...),
    x_public_key: str = Header(...),
    x_session_token: str = Header(...)
) -> BlockchainCredentials:
    """Mock implementation for development - accepts any valid-looking headers."""
    print(f"DEVELOPMENT MODE: Using mock blockchain verification")
    
    # Very basic validation to ensure headers look valid
    if not x_transaction_hash.startswith("0x") or len(x_transaction_hash) < 10:
        raise HTTPException(status_code=401, detail="Invalid transaction hash format")
        
    if not x_public_key or len(x_public_key) < 5:
        raise HTTPException(status_code=401, detail="Invalid public key format")
    
    if not x_session_token or len(x_session_token) < 10:
        raise HTTPException(status_code=401, detail="Invalid session token")
    
    # Always accept in development mode
    return BlockchainCredentials(
        transaction_hash=x_transaction_hash,
        public_key=x_public_key,
        session_token=x_session_token
    )

async def deduct_cv_credit(user_address: str, session_token: str) -> Dict[str, Any]:
    """
    Calls the XION blockchain contract to deduct a CV credit (-1) from the user's account.
    This must be called after successful CV generation.
    
    Args:
        user_address: The user's wallet address
        session_token: The session token from record_cv_generation
        
    Returns:
        Dict containing transaction result and remaining credits
    """
    try:
        # Per the contract, we need to sign: {user_address}{session_token}
        message = f"{user_address}{session_token}"
        
        # Create a signature for the message
        # In a production environment, we'd use a proper wallet to sign this
        # For now, we'll use a placeholder signature
        backend_wallet_address = os.getenv("BACKEND_WALLET_ADDRESS")
        if not backend_wallet_address:
            raise ValueError("BACKEND_WALLET_ADDRESS environment variable is not set")
            
        # In production, use a proper signing method with the backend wallet's private key
        # This is just a placeholder - replace with actual signing code
        signature = hashlib.sha256(message.encode()).hexdigest()
        
        print(f"Deducting CV credit for user: {user_address}")
        
        # Call the contract using the REST API
        async with httpx.AsyncClient(timeout=30.0) as client:
            # This simplified transaction request needs to be replaced with proper 
            # transaction creation, signing, and broadcasting in production
            tx_url = f"{XION_API_URL}/cosmos/tx/v1beta1/txs"
            
            response = await client.post(
                tx_url,
                headers={
                    "Content-Type": "application/json",
                    "Authorization": f"Bearer {XION_API_KEY}" if XION_API_KEY else ""
                },
                json={
                    "tx_body": {
                        "messages": [{
                            "@type": "/cosmwasm.wasm.v1.MsgExecuteContract",
                            "sender": backend_wallet_address,
                            "contract": XION_CONTRACT_ADDRESS,
                            "msg": {
                                "deduct_cv_credit": {
                                    "user_address": user_address,
                                    "signature": signature
                                }
                            },
                            "funds": []
                        }],
                        "memo": "CV Credit Deduction",
                        "timeout_height": "0"
                    },
                    "auth_info": {
                        "signer_infos": [],  # Would contain public key info in production
                        "fee": {
                            "amount": [{"denom": "uxion", "amount": "1000"}],
                            "gas_limit": "200000"
                        }
                    },
                    "signatures": []  # Would contain signatures in production
                }
            )
            
            if response.status_code not in (200, 201, 202):
                print(f"Error deducting CV credit: {response.status_code} - {response.text}")
                return {
                    "success": False,
                    "error": f"Failed to deduct credit: {response.text}"
                }
            
            result = response.json()
            
            # Extract credit information from the response
            tx_hash = result.get("tx_response", {}).get("txhash", "")
            
            # Parse events to get remaining credits
            remaining_credits = 0
            events = result.get("tx_response", {}).get("events", [])
            for event in events:
                if event.get("type") == "wasm":
                    for attr in event.get("attributes", []):
                        key = base64.b64decode(attr.get("key", "")).decode("utf-8", errors="ignore")
                        value = base64.b64decode(attr.get("value", "")).decode("utf-8", errors="ignore")
                        
                        if key == "credits_remaining":
                            remaining_credits = int(value)
            
            return {
                "success": True,
                "transaction_hash": tx_hash,
                "remaining_credits": remaining_credits
            }
            
    except Exception as e:
        print(f"Error deducting CV credit: {str(e)}")
        return {
            "success": False, 
            "error": str(e)
        }