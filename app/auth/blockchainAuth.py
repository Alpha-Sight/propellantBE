import os
import logging
from typing import Optional
from fastapi import Header, HTTPException, Request
from pydantic import BaseModel
from app.services.xion_rest_client import XionCLIClient

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize client
xion_client = XionCLIClient()

class BlockchainCredentials(BaseModel):
    user_address: str
    secure_token: str

async def verify_blockchain_credentials(
    request: Request,
    x_user_address: str = Header(..., description="User's wallet address"),
    x_secure_token: str = Header(..., description="Session token generated by the contract")
) -> BlockchainCredentials:
    """Verifies blockchain credentials from XION"""
    # Basic validation
    if not x_user_address or not x_user_address.startswith("xion"):
        raise HTTPException(status_code=401, detail="Invalid wallet address format")
    
    # Updated for real token format (3 parts)
    if not x_secure_token or len(x_secure_token.split(":")) < 3:
        raise HTTPException(status_code=401, detail="Invalid token format")
    
    # Create credentials object
    credentials = BlockchainCredentials(
        user_address=x_user_address,
        secure_token=x_secure_token
    )
    
    # PRODUCTION OPTION 1: Always accept for initial testing
    # Uncomment next two lines to bypass verification entirely
    # logger.warning("⚠️ PRODUCTION TESTING: Bypassing verification entirely")
    # return credentials
    
    # PRODUCTION OPTION 2: Try verification but accept on errors
    try:
        # Verify token 
        is_valid = await xion_client.verify_user_token(x_user_address, x_secure_token)
        
        if not is_valid:
            # PRODUCTION TESTING: Accept anyway for testing
            logger.warning("⚠️ PRODUCTION TESTING: Accepting despite verification failure")
            return credentials
            
            # REAL PRODUCTION: Use this instead
            # raise HTTPException(status_code=401, detail="Invalid blockchain credentials")
        
        logger.info(f"✅ Verified blockchain credentials for user: {x_user_address}")
        return credentials
    except Exception as e:
        logger.error(f"Authentication error: {str(e)}")
        
        # PRODUCTION TESTING: Accept anyway for testing
        logger.warning("⚠️ PRODUCTION TESTING: Accepting despite error")
        return credentials
        
        # REAL PRODUCTION: Use this instead
        # raise HTTPException(status_code=401, detail=f"Authentication error: {str(e)}")

# Mock implementation for development remains the same
async def mock_verify_blockchain_credentials(
    x_user_address: str = Header(...),
    x_secure_token: str = Header(...)
) -> BlockchainCredentials:
    """Mock implementation for development"""
    logger.info("DEVELOPMENT MODE: Using mock blockchain verification")
    
    # Basic validation
    if not x_user_address.startswith("xion"):
        raise HTTPException(status_code=401, detail="Invalid wallet address format")
        
    if not x_secure_token or len(x_secure_token.split(":")) < 3:
        raise HTTPException(status_code=401, detail="Invalid token format")
    
    # Always accept in development mode
    return BlockchainCredentials(
        user_address=x_user_address,
        secure_token=x_secure_token
    )

async def deduct_cv_credit(user_address: str, secure_token: str):
    """Deducts a CV credit from the user's account"""
    # For production testing, just return a successful mock response
    logger.warning("⚠️ PRODUCTION TESTING: Using mock credit deduction")
    return {
        "success": True,
        "tx_hash": "mock_tx_hash_production_test",
        "credits_remaining": 99
    }